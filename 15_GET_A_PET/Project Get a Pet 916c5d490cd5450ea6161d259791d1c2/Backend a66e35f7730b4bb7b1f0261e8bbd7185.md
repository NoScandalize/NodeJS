# Backend

### Configurações/instalações iniciais do projeto

Iniciamos o projeto com o **init**;

`npm init -y`

Em seguida as instalações das **libs** inicialmente necessárias;

`npm i bcrypt express cookie-parser cors jsonwebtoken mongoose multer nodemon`

Criaremos também uma estrutura de pastas seguindo a **arquitetura MVC** e também adicionamos mais algumas pasta que serão necessárias como por exemplo a **db** que ficará responsável pelo arquivo de conexão do banco de dados;

![Estruturação MVC inicial dos diretórios](Backend%20a66e35f7730b4bb7b1f0261e8bbd7185/Untitled.png)

Estruturação MVC inicial dos diretórios

Também criaremos o script start no package.json para executar a aplicação com o nodemon:

```json
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon ./index.js localhost 5000"
  }
```

E as configurações iniciais da aplicação(index.js):

```jsx
// ./index.js

const express = require('express');
const cors = require('cors');

const app = express();

// Config JSON response
app.use(express.json());

// Solve CORS
app.use(cors({ credentials: true, origin: 'http://localhost:3000' }))

// Public folder for images
app.use(express.static('public'))

// Routes

app.listen(5000)
```

### Criando a conexão com o banco e os models

É feita a conexão com o MongoDB através do mongoose e também já é feita a exportação:

```jsx
// ./db/conn.js

const mongoose = require('mongoose');
const chalk = require('chalk');

async function main() {
    await mongoose.connect('mongodb://127.0.0.1:27017/getapet')
    console.clear();
    console.log(chalk.green("Conexão efetuada com sucesso!"))
    console.log(chalk.magenta("Bem-vindo(a) ao MongoDB!"))
}

main().catch((err) => console.log(chalk.red(`Ocorreu um erro: ${err}`)))

module.exports = mongoose;
```

Em seguida fazemos a criação do primeiro model, o User.js;

```jsx
// ./models/User.js

const mongoose = require('./db/conn');
const { Schema } = mongoose;

const User = mongoose.model(
    'User',
    new Schema({
        name: {
            type: String,
            required: true,
        },
        email: {
            type: String,
            required: true,
        },
        password: {
            type: String,
            required: true,
        },
        image: {
            type: String,
        },
        phone: {
            type: String,
            required: true,
        },
      },
      { timestamps: true },
    ),
)

module.exports = User;
```

E também a criação e exportação do model Pet.js, os models são as nossas collections no banco de dados;

```jsx
// ./models/Pet.js

const mongoose = require('../db/conn');
const { Schema } = mongoose;

const Pet = mongoose.model(
    'Pet',
    new Schema({
        name: {
            type: String,
            required: true,
        },
        age: {
            type: Number,
            required: true,
        },
        weight: {
            type: Number,
            required: true,
        },
        color: {
            type: String,
            required: true,
        },
        images: {
            type: Array,
            required: true,
        },
        avaliable: {
            type: Boolean
        },
        user: Object,
        adpoter: Object,
      },
      { timestamps: true },
    ),
)

module.exports = Pet;
```

### Criando Controller e as rotas dos usuários

Agora iremos definir as rotas, e para isso criaremos o diretório ./routes e também criaremos o arquivo UserRoutes.js onde ficaram armazenadas as rotas dos usuários, em seguida faremos a importação e definição das rotas /users no index.js;

```jsx
// ./index.js

// Routes
const UserRoutes = require('./routes/UserRoutes');

app.use('/users', UserRoutes);
```

Em seguida faremos a criação da primeira rota do users que será uma rota post e irá executar um método register que será criado no controller isso através da rota /register, e não se esquecendo da exportação do router;

```jsx
// ./routes/UserRoutes.js

const router = require('express').Router();

const UserController = require('../controllers/UserController')

router.post('/register', UserController.register);

module.exports = router;
```

E então criaremos o UserController.js no diretório de controllers, criando o método register, e nele fazemos a importação do model User.js e também fazer a exportação do nosso controller através do module.exports;

```jsx
// ./controllers/UserController.js

const User = require('../models/User.js');

module.exports = class UserController {

    static async register(req, res) {

        res.json('Olá Get a Pet');
        
    }

}
```

### Criando o registro de usuários no sistema

Bom, precisamos escrever realmente o que o método register irá fazer, primeiramente iremos coletar alguns dados do body que virão da requisição, e em seguida iremos fazer algumas validação porque tais dados serão obrigatórios;

```jsx
// ./controlers/UserController.js

static async register(req, res) {

        const { name, email, phone, password, confirmpassword } = req.body;

        // validations
        if (!name) {
            res.status(422).json({ message: 'O nome é obrigatório' })

            return;
        }

        if (!email) {
            res.status(422).json({ message: 'O email é obrigatório' })

            return;
        }

        if (!phone) {
            res.status(422).json({ message: 'O telefone é obrigatório' })

            return;
        }

        if (!password) {
            res.status(422).json({ message: 'A senha é obrigatório' })

            return;
        }

        if (!confirmpassword) {
            res.status(422).json({ message: 'A confimação de senha é obrigatório' })

            return;
        }

        if(password !== confirmpassword) {
            res.status(422).json({ message: "A senha e a confirmação de senha precisam ser iguais!" })
            
            return;
        }
...
```

Agora faremos a verificação se o usuário que está sendo cadastrado já existe no banco, e para isso faremos o uso do método findOne e passamos um filtro que será o email, se o usuário já estiver cadastrado retornará um erro;

```jsx
// ./controllers/UserController.js// ./controllers/UserController.js

...
// check if user exists
const userExists = await User.findOne({ email: email })

if(userExists) {
     res.status(422).json({ message: "Email já cadastrado, por favor utilize outro e-mail" })
            
     return;
}
...
```

Uma etapa muito importante é a criptografia do password, para que em casos de vazamento de banco a senha do usuário não seja comprometida, então antes de enviar a senha iremos criptografa-la, primeiramente fazemos uso do salt que irá inserir 12 caracteres a mais e irá fortificar ainda mais a criptografia e em seguida criaremos o hash, que é o password já criptografado em uma hash;

 

```jsx
// ./controllers/UserController.js

...
// create a password
const salt = await bcrypt.genSalt(12);
const passwordHash = await bcrypt.hash(password, salt);
...
```

E com as senha já protegida, criaremos o user e através do método save do mongoose faremos a inserção dos dados do usuário no banco, para tratar os dados iremos usar o try/catch para caso ocorra um eventual erro informando o status 500 e uma message com o error e também precisamos fazer a importação da lib do bcrypt;

```jsx
// ./controllers/UserController.js

...
// create a user
const user = new User({
    name,
    email,
    phone,
    password: passwordHash,
})

try {

    const newUser = await user.save()

} catch(error) {

    res.status(500).json({ message: error })
    
}
...
```

### Criando a função de criação de token

Precisamos fazer com que o usuário faça o login juntamente com o cadastro e se mantenha logado, para isso iremos criar uma função que será criada nos helpers, neste caso iremos criar o arquivo create-user-token.js essa função irá criar um token que fará com que o usuário permaneça logado no sistema, essa função será usada no registro e também será reaproveitada no login, e para criar o token fazemos uso do método sign do jwt passando o que queremos que venha de dados junto ao token e também temos que passa um secret que é uma key que é usada na criação do token fazendo com que ele se torne unico;

```jsx
// ./helpers/create-user-token.js

const jwt = require('jsonwebtoken');

const createUserToken = async(user, req, res) => {

    // create a token
    const token = jwt.sign({
        name: user.name,
        id: user._id,
    }, "nossosecret")

    // return token
    res.status(200).json({
        message: "Você está autenticado",
        token: token,
        userId: user._id,
    })

}

module.exports = createUserToken;
```

E fazemos a execução desta função no UserController passando os dados do newUser para o parâmetro user e precisamos fazer a importação da função;

```jsx
// ./controllers/UserController.js
const createUserToken = require('../helpers/create-user-token.js')

...
try {

            const newUser = await user.save()
           
            await createUserToken(newUser, req, res);

        } catch(error) {

            res.status(500).json({ message: error })

}
...
```

### Criando a função de login de usuários no sistema

Agora criaremos o método de login no UserController , precisaremos dos dados email e senha que vem da requisição para executar as validações se algum dado não veio do body e as validações do banco, se todos as validações passarem utilizaremos a função helper createUserToken para criação do token e autenticação do usuário passando o user para os parâmetros da função;

```jsx
// ./controllers/UserController.js

static async login (req, res) {

        const { email, password } = req.body;

        if (!email) {
            res.status(422).json({ message: 'O email é obrigatório' })

            return;
        }

        if (!password) {
            res.status(422).json({ message: 'A senha é obrigatória' })

            return;
        }

        // check if user exists
        const user = await User.findOne({ email: email })

        if(!user) {
            res.status(422).json({
                message: "Usuário não cadastrado!"
            })

            return;
        }

        // check if password match with db password

        const checkPassword = await bcrypt.compare(password, user.password)

        if(!checkPassword) {
            res.status(422).json({
                message: "Senha inválida!"
            })

            return;
        }

        await createUserToken(user, req, res);
    }
```

Também é necessário criar a rota para execução do método;

```jsx
// ./routes/UserRoutes.js

...
router.post('/login', UserController.login)
...
```

Precisamos fazer a verificação do usuário através do token e para isso iremos criar o método checkUser no controller, só que para isso precisamos extrair o token da requisição então será necessário criar uma função no helper para fazer a extração, onde esta função irá nos retornar o token;

```jsx
// ./helpers/get-token.js

const getToken = (req) => {

    const authHeader = req.headers.autorization;
    const token = authHeader.split(" ")[1];

    return token;
}

module.exports = getToken;
```

### Criando a validação de usuários através do token

No UserController faremos a importação do helper get-token e criaremos o método check user onde faremos uma verificação se a autorização(token) está vindo dos headers, se der ok, faremos a decodificação do token através do método verify do jwt passando o token recebido dos headers e a secret utilizada na criação o token, lembrando que é necessário importar o jwt, depois de obtermos o objeto decodificado provindo do token, utilizamos ele como filtro para buscar no bando através do método findById, e o armazenamos, outro coisa muito importante é alterar o password para undefined para que não venha na resposta;

```jsx
// ./controllers/UserController.js

static async checkUser(req, res) {

        let currentUser;

        if(req.headers.authorization) {

            const token = getToken(req);
            const decoded = jwt.verify(token, 'nossosecret');

            currentUser = await User.findById(decoded.id);

            currentUser.password = undefined;

        } else {
            currentUser = null;
        }

        res.status(200).send(currentUser);

    }
```

### Criando a função de resgate de usuário através do id

Bom, agora criaremos uma rota onde irá executar uma função no controller, a função de coletar um usuário através do id, a getUserById;

```jsx
// ./routes/UserRoutes.js

...
router.get('/:id', UserController.getUserById);
...
```

No controller criamos o método getUserById onde fazemos uso do método findById do mongoose passando o id como argumento que vem dos parâmetros da url da requisição, antes de puxar os dados do usuário iremos fazer um verificação através de um método do mongoose para validar o id, precisamos sabe se é um id válido, então criamos um if para utilizamos o métido isValid passando o id, que retorna true se for um id válido, lembrando que é necessário fazer a importação do ObjectId do mongoose, com a verificação do id feita, partimos para o método findById que nos retorna todos os dados do user porém precisamos filtrar a senha para que ele não venha na resposta, então utilizando o método select junto do find passando como argumento “-password” fazendo com que a senha seja eliminada da coleta, fazemos uma verificação se o user existe;

```jsx
// ./controllers/UserController.js

...
const ObjectId = require('mongoose').Types.ObjectId;
...

...
static async getUserById (req, res) {

        const id = req.params.id;

				// check if id is a valid ObjectId
				if(!ObjectId.isValid(id)) {
            res.status(422).json({ message: 'Id inválido!' });
            return;
        }

        const user = await User.findById(id).select('-password');

        if(!user) {
            res.status(422).json({
                message: 'Usuário não encontrado!',
            })
            return;
        }

        res.status(200).json({ user });

    }
...
```

### Criação da função de edição de usuários

Agora criaremos o método de edição de usuários, para isso faremos a criação da rota, com é será uma atualização criaremos uma rota de patch, que será responsável pela execução do método editUser no controller;

```jsx
// ./routes/UserRoutes.js

...
router.patch('/edit/:id', UserController.editUser)
...
```

### Criando a validação do token

Porém precisamos que a rota de edição seja uma rota privada, onde só será possível ter acesso se o usuário estiver authenticado com um token especifico e para isso precisaremos criar um novo helper onde será um middleware que fará a verificação do token, só que antes precisaremos obter o token e para isso reutilizaremos a função getToken que criamos anteriormente, para isso fazemos a importação da mesma, agora faremos a verificação do token através de um try/catch fazendo uso do método verify passando o token que foi obtido e o secret se o token não for valido retornamos no catch uma message com status 400 de token inválido;

```jsx
// ./helpers/verify-token.js

const jwt = require('jsonwebtoken');
const getToken = require('./get-token')

// middleware to validade token
const checkToken = (req, res, next) => {

    if (!req.headers.authorization) {
        return res.status(401).json({ message: 'Acesso Negado!' })
    }

    const token = getToken(req);

    if(!token) {
        return res.status(401).json({ message: 'Acesso Negado!' })
    }

    try {
        
        const verified = jwt.verify(token, 'nossosecret');
        req.user = verified;
        next()

    } catch(err) {
        return res.status(400).json({ message: 'Token invalido!' })

    }
}

module.exports = checkToken;
```

Agora iremos fazer a importação do nosso middleware nas rotas e adicionaremos a nossa rota de edição;

```jsx
// ./routes/UserRoutes.js

// middleware
const **verifyToken** = require('../helpers/verify-token');

router.patch('/edit/:id', **verifyToken**, UserController.editUser)
```

Depois da criação da rota e validação de uso, iremos criar o método de edição de usuário no controller,  precisaremos de alguma forma identificar o usuário, e para isso utilizamos o token, então precisaremos criar um helper, que irá decodificar o token através do método verify do jwt passando o secret e irar retornar um userId onde utilizaremos no método findOne para trazer o usuário e então retorna-lo para o controller, também precisamo verificar se irá chegar o token.

```jsx
// ./helpers/get-user-by-token.js

const jwt = require('jsonwebtoken');

const User = require('../models/User')

// get user by jwt token
const getUserByToken = async (token) => {

    if(!token) {
        return res.status(401).json({ message: 'Acesso Negado!' })
    }

    const decoded = jwt.verify(token, 'nossosecret');

    const userId = decoded.id

    const user = await User.findOne({ _id: userId })

    return user;
}

module.exports = getUserByToken;
```

Bom, importamos a função helper no controller, passamos o token que vem do método getToken passando a requisição, agora precisaremos fazem mais algumas validações dos dados para edição que iremos puxar do corpo da requisição(body). Primeiro faremos a verificação do email que deve ser diferente do email atual do usuário e também de algum email já cadastrado para isso fazendo uso do método findOne do mongoose passando como filtro o email, também iremos fazer a verificação do nome, telefone e senha do usuário, no caso do senha precisamos verificar se é idêntico a confirmação  de senha, sempre é bom fazer o uso do postman para confirmar se as verificações estão funcionando corretamente, se as senhas correspondem então passamos para próxima verificação, na qual verificamos se a senha é diferente de null, se tudo está ok, passamos adiante para criação da nova senha, da mesma forma como anteriormente precisamos criptografar a nova senha e fazemos uso do bcrypt, primeiramente criando um salt que seria a adição de mais 12 caracteres a senha para torna-la mais forte e então a criptografamos em um hash. Depois de finalizarmos todas as verificações fazemos a alteração direto no user que coletamos através do token. Para fazer a atualização iremos utilizar o método findOneAndUpdate, nele passaremos o id na qual iremos fazer a atualização, passamos um operador $set passando o user na qual terá os dados que serão modificados e uma propriedade new informando que os dados serão alterados, para verificar que tudo deu certo, fazemos uso de um try/catch.

```jsx
// ./controllers/UserController.js

...
static async editUser (req, res) {

        // check if user exists
        const token = getToken(req)
        const user = await getUserByToken(token);

        const { name, email, phone, password, confirmpassword } = req.body;

        let image = '';

        // validations
        if (!name) {
            res.status(422).json({ message: 'O nome é obrigatório' })

            return;
        }

        user.name = name;

        if (!email) {
            res.status(422).json({ message: 'O email é obrigatório' })

            return;
        }

        // check if email has already taken
        const userExists = await User.findOne({ email: email });

        if (user.email !== email && userExists) {
            res.status(422).json({
                message: 'Por favor, utilize outro email!'
            })
            return;
        }

        user.email = email;

        if (!phone) {
            res.status(422).json({ message: 'O telefone é obrigatório' })

            return;
        }

        user.phone = phone;

        if(password != confirmpassword) {
            res.status(422).json({ message: "As senhas não conferem!" })
            return;
        } else if(password === confirmpassword && password != null) {

            // creating password
            const salt = await bcrypt.genSalt(12);
            const passwordHash = await bcrypt.hash(password, salt);

            user.password = passwordHash;

        }

        try {

            // return user updated data
            await User.findOneAndUpdate(
                { _id: user._id },
                { $set: user },
                { new: true },
            )

            res.status(200).json({
                message: "Usuário atualizado com sucesso!"
            })

        } catch (err) {

            res.status(500).json({ message: err })

        }

    }
...
```

### Upload de imagens

Ainda na nossa rota de edição, precisamos adicionar um middleware para receber os upload das imagens que poderão se inseridas no edit, então criaremos um helper para algumas configurações do multer que será responsável pela manipulação das files. Depois da importação do multer e do path, precisamos direcionar as imagens para um storage fazemos isso através do método diskStorage do multer passando um destino e o nome do arquivo, utilizamos dados da URL da requisição para identificar se o arquivo é de um usuário ou de algum pet e com isso criaremos os diretórios distintamente através da callback. Na criação do nome do arquivo fazemos uma concatenação entre a data atual em milissegundos e a extensão do arquivo original. Antes de exporta, precisamos adicionar um filtro para que apenas arquivos com as extensões corretas sejam enviados, então passamos as configs de storage pro multer adicionamos o fileFilter que aceitará apenas arquivos com a extensão png/jpg, então exportamos o nosso middleware.

```jsx
// ./helpers/image-upload.js

const multer = require('multer');
const path = require('path');

// Destination to store the images
const imageStorage = multer.diskStorage({
    destination: function (req, file, cb) {

        let folder = "";

        if(req.baseUrl.includes("users")) {

            folder = "user";

        } else if (req.baseUrl.includes("pets")) {

            folder = "pet"

        }

        cb(null, `public/images/${folder}`)

    },
    filename: function (req, file, cb) {

        cb(null, Date.now() + path.extname(file.originalname))

    }
})

const imageUpload = multer({
    storage: imageStorage,
    fileFilter(req, file, cb) {
        if(!file.originalname.match(/\.(png|jpg)$/)) {
            return cb(new Error("Por favor, envie apenas jpg ou png!"))
        }
        cb(undefined, true)
    }
})

module.exports = { imageUpload };
```

Então fazemos a importação do middleware nas rotas e adicionamos a rota patch de edição, utilizando o método single, que no caso será apenas uma única imagem e contendo o argumento “image” que será o nome do campo no nosso formulário de envio.

```jsx
// ./routes/UserRoutes.js

...
router.patch('/edit/:id', verifyToken, **imageUpload.single("image")**, UserController.editUser);
...
```

Feito isso, iremos adicionar o arquivo de imagem que virá da requisição do formulário no controller, primeiro fazemos uma verificação se o arquivo chegou e depois armazenamos no user.

```jsx
// ./controllers/UserController.js

...
// upload image
        if(req.file) {
            user.image = req.file.filename;
        }
...

```

Para verificar se a imagem está sendo registrada no banco e está sendo armazenada no public fazemos uso do postman para enviar um request  patch  form-data adicionando o image no tipo file e enviamos a imagem.

![Untitled](Backend%20a66e35f7730b4bb7b1f0261e8bbd7185/Untitled%201.png)

Então verificamos no banco o registro da imagem.

![Untitled](Backend%20a66e35f7730b4bb7b1f0261e8bbd7185/Untitled%202.png)

### Dando inicio as rotas de Pets

Nas routes criamos o PetRoutes.js e criamos a nossa primeira rota, a create, esta rota ficará responsável por executar a função de criação dos pets no controller que iremos criar em seguida.

```jsx
// ./routes/PetRoutes.js

const router = require('express').Router();

const PetController = require('../controllers/PetController');

router.post('/create', PetController.create);

module.exports = router;
```

Então criamos o nosso controller e adicionamos o método create que será responsável pela criação dos pets.

```jsx
// ./controllers/PetController.js

const Pet = require('../models/Pet')

module.exports = class PetController {

    // create a pet
    static async create(req, res) {
        res.json({ message: "Criado com sucesso!" })
    }

}
```

Para que isso esteja conectado a aplicação precisamos adicionar a rota no index.js

```jsx
// ./index.js

...
const PetRoutes = require('./routes/PetRoutes');
...
app.use('/pets', PetRoutes);
...
```

Verificamos no postman se a rota e o controller estão ok e então seguimos.

![Untitled](Backend%20a66e35f7730b4bb7b1f0261e8bbd7185/Untitled%203.png)

Continuando na rota de criação de pets precisamos adicionar um middleware a rota, o verifyToken para fazer a verificação se o usuário que está cadastrando o pet possui um token válido, 

```jsx
// ./routes/PetRoutes.js

...
// middlewares
const verifyToken = require('../helpers/verify-token')

router.post('/create', verifyToken, PetController.create);
...
```

### Criando método para receber múltiplas imagens

Antes de partimos para o método create no controller, vamos adicionar outro middleware a rota para o upload de imagens, nesta caso múltiplas imagens, para isso utilizamos o método array do middleware passando o argumento ‘images’ que será o nome do dado que virá do form;

```jsx
// ./routes/PetRoutes.js

...
const { imageUpload } = require('../helpers/image-upload')

router.post('/create', verifyToken, imageUpload.array('images'), PetController.create);
...
```

### Criando a função de registro de pets no sistema

Agora iremos de fato trabalhar no método create, primeiramente iremos coletar os dados que vem da requisição e vamos passar eles por algumas validações para ter certeza que todos chegaram, outra dado que precisamos antes da criação do pet no banco é os dados do dono do pet no caso o user, então vamos identificar o usuário pelo token, para isso utilizamos o helper criado anteriormente para coletar o token de autenticação do usuário que vem da requisição, com o token em mãos, puxamos do banco o usuário através do token.

```jsx
// ./controllers/UserController.js

...
// create a pet
    static async create(req, res) {
        
        const { name, age, weight, color } = req.body;

        const available = true;

        // images upload
        const images = req.files;

        // validations 
        if(!name) {
            res.status(422).json({ message: "O nome é obrigatório!" })
            return;
        }

        if(!age) {
            res.status(422).json({ message: "A idade é obrigatória!" })
            return;
        }

        if(!weight) {
            res.status(422).json({ message: "O peso é obrigatório!" })
            return;
        }

        if(!color) {
            res.status(422).json({ message: "A cor é obrigatória!" })
            return;
        }

        if(images.length === 0) {
            res.status(422).json({ message: "A imagem é obrigatória!" })
        }

        // get pet owner
        const token = getToken(req);
        const user = await getUserByToken(token)

        // create a pet
        const pet = new Pet({
            name,
            age,
            weight,
            color,
            available,
            images: [],
            user: {
                _id: user._id,
                name: user.name,
                image: user.image,
                phone: user.phone,
            }
        })

        images.map((image) => {
            pet.images.push(image.filename)
        })

        try {

            const newPet = await pet.save();
            res.status(201).json({
                message: 'Pet cadastrado com sucesso!',
                newPet,
            })

        } catch (error) {
            res.status(500).json({ message: error })
        }

    }
...
```

### Criando o resgate de todos os pets

Para iniciar, criamos a rota get para executar a função de coleta no controller. Nesta rota não é necessária nenhuma verificação pois é uma rota publica, então qualquer usuário com/sem cadastro pode acessa-la.

```jsx
// ./routes/PetRoutes.js

...
router.get('/', PetController.getAll);
...
```

Então partimos para a criação o método getAll no controller, que a principio será bem simples, precisamos apenas puxar os dados do banco através do método find e com auxilio do método sort ordenamos os pets pela data de criação, como passamos o -createdAt ele ordenará em ordem crescente, sempre do ultimo criado até o primeiro, lembrando de utilizar o await pois estamos fazendo um requisição assíncrona ao banco e então retornamos os pets na resposta.

```jsx
// ./controllers/PetController.js

...
static async getAll (req, res) {

        const pets = await Pet.find().sort('-createdAt')

        res.status(200).json({
            pets: pets,
        })

    }
...
```

Fazemos o uso do postman para verificar a funcionalidade.

![Untitled](Backend%20a66e35f7730b4bb7b1f0261e8bbd7185/Untitled%204.png)

### Criando o resgate de pets vinculados aos usuários

Agora criaremos uma função que irá resgatar apenas os pets que foram cadastrados pelo usuário, para isso iniciaremos com a criação da uma rota get que nos levará a execução do método getAllUserPets no controller, esta rota será privadas, pois apenas o usuário responsável pelo cadastro terá acesso, e para isso fazemos o uso do middleware verifyToken, permitindo acesso apenas ao usuário com token autenticado.

```jsx
// ./routes/PetRoutes.js

...
router.get('/mypets', verifyToken, PetController.getAllUserPets)
...
```

No controller, damos inicio a criação do método getAllUserPets que será semelhante ao método anterior, o getAll, a diferença é que agora passamos um filtro, no caso o id do usuário, pois iremos buscar apenas os pets cadastrados pelo usuário. 

```jsx
// ./controllers/PetController.js

...
static async getAllUserPets (req, res) {

        // get user from token
        const token = getToken(req);
        const user = await getUserByToken(token);

        const pets = await Pet.find({'user._id': user._id}).sort('-createdAt');

        res.status(200).json({
            pets,
        })

    }
...
```

### Criando o resgatar os pets adotados pelo usuário

Vamos criar a função que irá regatar os pets que foram adotados por um usuário. Iniciaremos pela criação de uma rota get onde faremos também a adição do método que verificará o token.

```jsx
// ./routes/PetRoutes.js

...
router.get('/myadoptions', verifyToken, PetController.getAllUserAdoptions);
...
```

Em seguida iremos criar o método getAllUserAdoptions que será responsável pela coleta dos pets adotados pelo usuário especificado para isso fazemos o mesmo processo da função anterior, pegamos o usuário através do token e então através do método find passando  em todos os pets registrados passando um filtro onde buscará pelos pets que foram adotados por um determinado usuário, para que isso funcional, posteriormente será adicionado um função onde criará um objeto adopter no em cada pet no banco que receberar um id que fará referência ao usuário em questão, através deste dado conseguiremos buscar quais pets determinado usuário adotou.

```jsx
// ./controllers/PetController.js

...
static async getAllUserAdoptions (req, res) {

        // get user from token
        const token = getToken(req);
        const user = await getUserByToken(token);

        const pets = await Pet.find({'adopter._id': user._id}).sort('-createdAt');

        res.status(200).json({
            pets,
        })
...
```

### Criando o resgate de pets pelo id

Outra função que será criada será a de coletar dados de um pet especifico através de seu id, para iniciarmos como de costume vamos criar uma rota get onde id do pet será passado na URL, e esta rota executará o método getPetById que criaremos no controller.

```jsx
// ./routes/PetRoutes.js

...
router.get('/:id', PetController.getPetById)
...
```

Agora iremos efetuar a criação deste método no controller, para isso precisaremos  do id do pet, então iremos coletar através dos paremetros da URL, que vem da requisição, e então precisamos fazer uma verificação se o id passado é válido. Temos um helper do próprio mongoose que faz essa verificação, então fazemos a importação deste método e executamos a checagem, se o id for válido, partiremos para requisição do dado no banco, utilizamos um findOne filtrando pelo id, também verificamos se os dados chegaram, se tudo ok, retornamos uma resposta com os dados do pet.

```jsx
// ./controller/PetController.js

...
const ObjectId = require('mongoose').Types.ObjectId;
...

...
static async getPetById (req, res) {

        const id = req.params.id;

        if(!ObjectId.isValid(id)) {
            res.status(422).json({ message: 'Id inválido!' });
            return;
        }

        // check if pet exists
        const pet = await Pet.findOne({_id: id})

        if(!pet) {
            res.status(404).json({ message: 'Pet não encontrado!' })
            return;
        }

        res.status(200).json({
            pet: pet,
        })

    }
...
```

### Removendo Pet do sistema

Bom, agora criaremos a remoção de pets do sistema, primeiramente iniciamos com o de costume, iremos criar uma rota, e ela agora será uma rota “delete”, e também usaremos o id para identificar o pet que iremos remover, como não queremos que qualquer usuário consiga acesso a essa rota, usaremos o middleware verifyToken para validar o acesso a rota através do token de autenticação. O usuário que estiver autenticado conseguirá prosseguir e executará o método removePetById no controller.

```jsx
// ./routes/PetRoutes.js

...
router.delete('/:id', verifyToken, PetController.removePetById);
...
```

Com a rota definida, precisaremos criar o método que será executado pela rota, o método removePetById, então partimos para o controller. Para darmos inicio, necessitaremos coletar o id, isso através dos parâmetros da URL que vem da requisição, e de como de costume, iremos também fazer uma validação com o id, é necessário verificar se é um id valido, iremos fazer como na função anterior, utilizando o método isValid do ObjectId que importamos do mongoose. Depois de validado o id, vamos verificar se o pet existe no sistema, então iremos buscar no banco o pet através do id, faremos isso utilizando o findOne passando como filtro o id, e então checamos através do if se é retornado algum pet do banco, se obtemos um retorno true, continuaremos para o próximo passo que também será mais um verificação, agora precisamos verificar se o usuário que está tentando fazer a remoção foi quem originou o registro do pet no sistema, e para isso utilizaremos o token para identificar o usuário e assim comparar com o usuário efetuou o registro do pet no sistema. Se todas as verificações passaram então executaremos a remoção do pet, utilizaremos o método findByIdAndRemove do mongoose passando o id como argumento lembrando de utilizar um await pra aguarda a solicitação ser finalizada e retornamos um status 200 de sucesso na remoção do pet.

```jsx
// ./controllers/PetController.js

...
static async removePetById (req, res) {

        const id = req.params.id;

        // check if ID is valid
        if(!ObjectId.isValid(id)) {

            res.status(422).json({ message: 'ID inválido!' })
            return;

        }

        // check if pet exists
        const pet = await Pet.findOne({ _id: id })

        if(!pet) {

            res.status(404).json({ message: 'Pet não encontrado!' })
            return;

        }

        // check if logged in user registered the pet
        const token = getToken(req);
        const user = await getUserByToken(token);

        if(pet.user._id.toString() !== user._id.toString()) {

            res.status(422).json({ message: 'Houve um problema em processar a sua solicitação, tente novamente mais tarde.' })
            return;

        }

        await Pet.findByIdAndRemove(id);

        res.status(200).json({ message: 'Pet REMOVIDO com sucesso!' })

    }
...
```

### Criando a função de atualização de pets

Iniciaremos com a criação da rota, será um rota de atualização(patch), onde será passado o id do pet a ser editado, precisaremos verificar o usuário que estará acessando a rota, pois só poderá ter acesso a rota o usuário que registrou o pet especificado, e também precisaremos do helper de upload de imagens. A rota irá executar o método updatePet no controller. 

```jsx
router.patch('/:id', verifyToken, imageUpload.array('images'), PetController.updatePet)
```

No controller iremos coletar o id através da URL,  alguns dados do corpo(body), as imagens que vem da requisição e também criaremos o updatedData onde inicialmente será um objeto vazio porém posteriormente será onde irá ficar os dados que serão atualizados do pet ao longo do processo. Também checaremos se o pet existe fazendo um busca no banco filtrando pelo id e também verificamos se o pet pertence ao usuário que está logado fazendo a checagem através do token e comparando o usuário relativo ao token com o usuário que vem cadastrado com o pet no banco. Precisamos também fazer as validações de cada um do dados que vem do body e as imagens, se todos eles chegam. Se tudo chegou faço a atribuição de todos ao updatedData sendo que nas imagens é utilizado um map por se tratar de um array. Por fim depois de todas as validações é feita o update no banco, através do método findByIdAndUpdate passando como argumento o id e o objeto updatedData qua são os dados a serem atualizados.

```jsx
// ./controllers/PetController.js

...
static async updatePet(req, res) {

        const id = req.params.id;

        const { name, age, weight, color, available } = req.body;

        const images = req.files;

        const updatedData = {};

        // check if pet exists
        const pet = await Pet.findOne({ _id: id })

        if (!pet) {
            res.status(404).json({ message: 'Pet não encontrado!' });
            return;
        }

        // check if logged in user registered the pet
        const token = getToken(req);
        const user = await getUserByToken(token);

        if(pet.user._id.toString() !== user._id.toString()) {

            res.status(422).json({ message: 'Houve um problema em processar a sua solicitação, tente novamente mais tarde.' })
            return;

        }

        // validations 
        if(!name) {
            res.status(422).json({ message: "O nome é obrigatório!" })
            return;
        } else {
            updatedData.name = name;
        }

        if(!age) {
            res.status(422).json({ message: "A idade é obrigatória!" })
            return;
        } else {
            updatedData.age = age;
        }

        if(!weight) {
            res.status(422).json({ message: "O peso é obrigatório!" })
            return;
        } else {
            updatedData.weight = weight;
        }

        if(!color) {
            res.status(422).json({ message: "A cor é obrigatória!" })
            return;
        }  else {
            updatedData.color = color;
        }

        if(images.length === 0) {
            res.status(422).json({ message: "A imagem é obrigatória!" })
        }  else {
            updatedData.images = [];
            images.map((image) => {
                updatedData.images.push(image.filename);
            })
        }

        await Pet.findByIdAndUpdate(id, updatedData);

        res.status(200).json({ message: 'Pet atualizado com sucesso!' })

    }
...
```

### Criando a função de agendamento de visitas para adoção

Como de costume damos inicio pela criação da rota, neste caso também será uma rota do tipo patch, precisaremos também de uma verificação através do token, então utilizaremos o middleware.

```jsx
// ./routes/PetRoutes.js

...
router.patch('/schedule/:id', verifyToken, PetController.schedule);
...
```

Então partimos para o controller, onde criaremos o método que será executado pela rota. Neste método precisaremos do id do pet que virá pela URL através do parâmetro da requisição, verificamos se o este id é valido, também verificamos se o pet que vem da requisição existe e se o pet não for do usuário que está logado, pois ele não pode agendar uma visita com pet que foi registrado por ele mesmo. Precisamos fazer mais um validação, verificaremos se o usuário que está tentando fazer a visita já tenha agendado uma visita anteriormente. Depois das validações faremos a adição do usuário a adoção do pet, iremos fazer um update no pet no objeto adpoter passando os dados o usuário que irá adotar e em seguida fazemos a atualização do pet no banco.

```jsx
// ./controller/PetController.js

...
static async schedule (req, res) {

        const id = req.params.id;

         // check if ID is valid
         if(!ObjectId.isValid(id)) {

            res.status(422).json({ message: 'ID inválido!' })
            return;

        }

        // check if pet exists
        const pet = await Pet.findOne({ _id: id })

        if (!pet) {
            res.status(404).json({ message: 'Pet não encontrado!' });
            return;
        }

        // check if logged in user registered the pet
        const token = getToken(req);
        const user = await getUserByToken(token);

        if(pet.user._id.equals(user._id)) {

            res.status(422).json({ message: 'Você não pode agendar uma visita com o seu próprio pet!' })
            return;

        }

        // check if user has already scheduled a visit
        if (pet.adpoter) {
            if(pet.adpoter._id.equals(user._id)) {
                res.status(422).json({
                    message: 'Você já agendou uma visita para este Pet!',
                })
            }
        }

        // add user to pet
        pet.adpoter = {
            _id: user._id,
            name: user.name,
            image: user.image,
        }

        await Pet.findByIdAndUpdate(id, pet)

        res.status(200).json({ message: `A visita foi agendada com sucesso, entre em contato com ${pet.user.name} pelo telefone ${pet.user.phone}!` })

    }
...
```

### Criação da função de conclusão da adoção

Partimos para criação da rota que irá ser idêntica a anterior, iremos utilizar o id na URL e também precisaremos da verificação do token.

```jsx
// ./routes/PetRoutes.js

...
router.patch('/conclude/:id', verifyToken, PetController.concludeAdoption);
...
```

No controller faremos a coleta do id que vem dos parâmetros da requisição e validamos com anteriormente, se o id é valido, se o pet existe no banco e se o pet pertence ao usuário que está logado, pois apenas o usuário que fez o cadastro do pet poderá confirmar a adoção. Em seguida passo o status de avaliable do pet para false, indicando que o pet não está mais disponível para adoção e faço o update através do método findByIdAndUpdate passando o id e o pet e respondo com status 200 de sucesso.

```jsx
// ./controllers/PetController.js

...
static async concludeAdoption (req, res) {

        const id = req.params.id;

        // check if ID is valid
         if(!ObjectId.isValid(id)) {

            res.status(422).json({ message: 'ID inválido!' })
            return;

        }

        // check if pet exists
        const pet = await Pet.findOne({ _id: id })

        if (!pet) {
            res.status(404).json({ message: 'Pet não encontrado!' });
            return;
        }

        // check if logged in user registered the pet
        const token = getToken(req);
        const user = await getUserByToken(token);

        if(pet.user._id.toString() !== user._id.toString()) {

            res.status(422).json({ message: 'Houve um problema em processar a sua solicitação, tente novamente mais tarde.' })
            return;

        }

        pet.avaliable = false;

        await Pet.findByIdAndUpdate(id, pet);

        res.status(200).json({ message: 'Parabéns! O ciclo de adoção foi finalizado com sucesso!' })

    }
...
```

E então concluímos as operações do back-end, agora partiremos para o front!